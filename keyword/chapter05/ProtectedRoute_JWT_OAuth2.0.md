- JWT
    - JWT(Json Web Token) 란 무엇인가?
        
        ### JWT (Json Web Token)이란 무엇인가?
        
        **정의**
        
         `JWT`는 JSON 형식의 데이터를 안전하게 전달하기 위한 토큰입니다. 서버는 사용자가 로그인하면 `JWT`를 생성하여 클라이언트에 전달하고, 클라이언트는 이 **토큰을 API 요청 시 함께 보내어 인증된 사용자임을 증명**합니다.
        
        **용도**
        
         **인증(Authentication):** 사용자가 로그인한 후, 서버는 **`JWT`**를 발급하고 클라이언트는 이후 요청 시 이 토큰을 사용하여 본인의 신원을 증명합니다.
        
         **정보 교환(Information Exchange):** **`JWT`**에는 사용자 정보나 기타 필요한 데이터를 담아 안전하게 전달할 수 있습니다.
        
    - JWT의 구성
        
        ### JWT의 구성
        
        JWT는 세 부분으로 구성되어 있으며, 각각은 점(`.`)으로 구분됩니다.
        
        **1. 헤더 (Header)**
        
        - 토큰의 타입(JWT)과 사용된 서명 알고리즘(예: HS256, RS256 등)을 명시합니다.
        
        EX)
        
        ```tsx
        {
          "alg": "HS256",
          "typ": "JWT"
        }
        ```
        
        **2. 페이로드 (Payload)**
        
        - 사용자 정보, 권한, 만료 시간(exp) 등 실제로 전달하고자 하는 데이터를 포함합니다.
        - 이 정보는 일반적으로 암호화되지 않으므로 민감한 데이터는 포함하지 않아야 합니다.
        
        ```tsx
        {
          "sub": "1234567890",
          "name": "Matthew Kim",
          "iat": 1516239022,
          "exp": 1516242622
        }
        ```
        
        **3. 서명(Signature)**
        
        - 헤더와 페이로드를 Base64Url로 인코딩한 값을 비밀키(또는 공개/개인키 쌍)를 사용하여 서명합니다.
        - 이 서명은 토큰이 변조되지 않았음을 확인하는 역할을 합니다.
        
        ---
        
    - JWT의 동작 원리 (전지적 WEB 시점)
        
        ### JWT의 동작 원리 (WEB 시점)
        
        1. **로그인 및 토큰 발급:**
            
            사용자가 로그인하면, 서버는 사용자를 인증한 후 JWT를 생성하여 클라이언트에 전달합니다.
            
        2. **토큰 저장:**
            
            클라이언트는 이 JWT를 브라우저의 로컬 스토리지 또는 쿠키에 저장할 수 있습니다.
            
            > 주의: 저장 방식에 따라 XSS나 CSRF 공격 위험이 있으므로 보안에 신경 써야 합니다.
            > 
        3. **요청 시 토큰 전달:**
            
            클라이언트는 API 요청 시 HTTP 헤더의 **`Authorization`** 필드에 **`"Bearer {토큰}"`** 형식으로 JWT를 포함합니다.
            
            ```tsx
            Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
            ```
            
        4. **서버에서 토큰 검증:**
            
            서버는 수신한 JWT를 검증하여 사용자의 인증 정보를 확인하고 요청을 처리합니다.
            
        
        ---
        
    - JWT 사용 시 보안 고려 사항
        
        ### JWT 사용 시 보안 고려 사항
        
        - **민감한 정보 포함 주의:**
            
            JWT의 페이로드는 암호화되지 않고 Base64Url로 인코딩되므로, 사용자 개인정보나 민감한 데이터를 담지 않아야 합니다.
            
        - **만료시간(exp) 설정:**
            
            토큰 탈취 시 위험을 줄이기 위해 반드시 만료 시간을 설정하고, 필요 시 갱신(refresh) 로직을 구현합니다.
            
        - **통신 보안:**
            
            HTTPS 프로토콜을 사용하여 네트워크 상의 데이터 노출을 방지합니다.
            
        - **저장 위치:**
            
            로컬 스토리지, 세션 스토리지 또는 쿠키에 저장할 때 XSS, CSRF 공격에 주의해야 하며, 보안 설정을 강화합니다.
            
- Cookie 🍪
    - 쿠키의 구성 요소
        
        ### 쿠키의 구성 요소
        
        쿠키는 여러 속성을 가지며, 각 속성은 쿠키의 동작과 보안에 영향을 미칩니다.
        
        - **이름(Name)과 값(Value)**
            
            쿠키의 핵심 데이터로, 이름과 그에 해당하는 값을 저장합니다.
            
        - **도메인(Domain)**
            
            쿠키가 유효한 도메인을 지정합니다. 지정된 도메인 내에서만 쿠키가 전송됩니다.
            
        - **경로(Path)**
            
            쿠키가 적용되는 URL 경로를 지정하여, 특정 경로에서만 쿠키가 사용되도록 제한할 수 있습니다.
            
        - **만료 시간(Expires) 및 최대 수명(Max-Age)**
            
            쿠키의 유효 기간을 설정합니다. 만료 시간이 지나면 브라우저는 해당 쿠키를 삭제합니다.
            
        - **보안 속성**
            - **Secure:** HTTPS 연결일 때만 쿠키가 전송됩니다.
            - **HttpOnly:** 클라이언트 측 스크립트(JavaScript)에서 접근할 수 없도록 하여 XSS 공격 위험을 줄입니다.
            - **SameSite:** 쿠키가 크로스 사이트 요청에 포함되는 방식을 제어해 CSRF 공격을 방지할 수 있습니다.
        
    - 쿠키의 동작 원리
        
        ### 쿠키의 동작 원리
        
        - **설정:**
            - 서버는 HTTP 응답 헤더의 `Set-Cookie` 필드를 사용해 쿠키를 브라우저에 설정합니다.
            - 예
                
                ```
                Set-Cookie: sessionId=abc123; Path=/; Expires=Wed, 21 Oct 2025 07:28:00 GMT; Secure; HttpOnly; SameSite=Strict
                ```
                
        - **저장**
            - 브라우저는 서버로부터 받은 쿠키를 내부 저장소에 보관하며, 지정된 도메인 및 경로에 따라 관리합니다.
        - **전송**
            - 사용자가 같은 도메인으로 요청을 보낼 때마다 브라우저는 해당 쿠키를 HTTP 요청 헤더의 `Cookie` 필드를 통해 자동으로 전송합니다.
        
    - 쿠키의 사용 예시
        
        ### 쿠키의 사용 예시
        
        쿠키는 다양한 용도로 활용됩니다. 몇 가지 예시는 다음과 같습니다.
        
        - **세션 관리**
            - 사용자가 로그인하면 서버는 세션 ID를 쿠키에 저장해, 이후 요청 시 사용자 인증 정보를 확인합니다.
        - **사용자 선호도 저장**
            - 테마, 언어, 페이지 레이아웃 등의 개인 설정을 쿠키에 저장하여 다음 방문 시 같은 환경을 제공합니다.
        - **분석 및 추적**
            - 사용자의 방문 기록이나 행동 패턴을 분석하기 위해 쿠키를 사용하여 데이터를 수집할 수 있습니다.
        
    - 보안 고려 사항
        
        ### 보안 고려 사항
        
        쿠키는 매우 유용하지만, 잘못 사용하면 보안 취약점이 될 수 있습니다.
        
        - **XSS (교차 사이트 스크립팅):**
            - 쿠키에 민감한 데이터를 저장할 때 `HttpOnly` 옵션을 사용해 클라이언트 스크립트로부터 보호합니다.
        - **CSRF (사이트 간 요청 위조):**
            - `SameSite` 옵션을 적절히 설정해, 다른 도메인에서 발생하는 요청에 쿠키가 포함되지 않도록 합니다.
        - **쿠키 도난:**
            - `Secure` 옵션을 사용해 `HTTPS` 연결에서만 쿠키가 전송되도록 하며, HTTPS 사용을 권장합니다.
        - **쿠키 크기 및 수 제한:**
            - `쿠키는 용량이 제한`되어 있으며, `도메인 당 저장할 수 있는 쿠키 수에도 제한`이 있으므로 필요한 데이터만 저장해야 합니다.
        
- Refresh Token 🍠
    - Refresh Token 정의
        
        ### Refresh Token 정의
        
        - **Access Token과의 차이:**
            
            Access Token은 보호된 리소스에 접근할 수 있도록 해주지만, 만료 시간이 짧게 설정되어 있습니다. 반면, Refresh Token은 상대적으로 긴 유효 기간을 가지며, 만료된 Access Token을 갱신하는 데 사용됩니다.
            
        - **역할:**
            - 사용자가 로그인을 다시 하지 않아도 지속적인 인증 상태를 유지하게 해줍니다.
            - 보안을 강화하면서도 사용자 경험을 개선합니다.
    - Refresh Token 동작 원리
        
        ### Refresh Token 동작 원리
        
        - **초기 발급**
            
            사용자가 인증을 완료하면, 인가 서버는 `Access Token`과 함께 `Refresh Token`을 함께 발급합니다.
            
        - **토큰 저장**
            
            클라이언트는 `Access Token`과 `Refresh Token`을 안전하게 저장합니다.
            
            - 보안상의 이유로 `HTTPOnly 쿠키`나 안전한 스토리지에 저장하는 것이 좋습니다.
        - **Access Token 만료**
            
            일정 시간이 지나 `Access Token`이 만료되면, 클라이언트는 `Refresh Token`을 이용해 새로운 `Access Token`을 요청합니다.
            
        - **토큰 갱신**
            
            인가 서버는 `Refresh Token`의 유효성을 검증한 후 새로운 `Access Token`(및 경우에 따라 새로운 `Refresh Token`)을 발급합니다.
            
    - 보안 고려 사항
        
        ### 보안 고려 사항
        
        - **안전한 저장소**
            
            `Refresh Token`은 민감 정보이므로, XSS나 CSRF 공격에 취약하지 않은 `HTTPOnly 쿠키`나 보안 스토리지에 저장해야 합니다.
            
        - **유효 기간 관리**
            
            `Refresh Token`의 만료 시간을 적절히 설정하여 장기적인 보안 위협을 최소화합니다.
            
        - **토큰 재사용 방지**
            
            `Refresh Token`이 탈취될 경우를 대비하여, 인가 서버에서 한 번 사용된 `Refresh Token`을 무효화하거나 새로운 토큰으로 교체하는 정책을 적용할 수 있습니다.
            
        - **폐기 정책**
            
            사용자가 로그아웃하거나 의심스러운 활동이 감지되면, `Refresh Token`을 즉시 폐기하여 추가적인 인증 요청이 불가능하도록 해야 합니다.
            
        
    - XSS 공격 / CSRF 공격 🍠
        
        <aside>
        🍠
        
        XSS 공격과 CSRF 공격에 대해 직접 정리해보세요!
        
        </aside>
        
        - XSS 공격 (Cross Site Scripting)
            
            : 웹 애플리케이션에 악성 스크립트를 삽입해, 최종 사용자의 브라우저에서 실행되도록 하는 공격 기법이며, XSS를 통해 공격자는 세션 탈취, 피싱, 악성 코드 배포 등 다양한 악의적 행위를 할 수 있음!
            
            Tmi : Cross Site Scripting의 약자로 엄밀히 말하면 CSS라고 하는 것이 맞지만 이미 CSS가 Cascading Style Sheets의 약어로 사용되고 있어 XSS라 한다.
            
            - XSS란 무엇인가?
            : 웹 페이지에 사용자로부터 입력된 데이터를 제대로 검증·처리하지 않고 그대로 출력할 때, 공격자가 삽입한 스크립트가 브라우저에서 실행되어 발생하는 보안 취약점이다.
            - 어떤 문제가 발생할 수 있는가?
            : 실행된 스크립트는 사용자 쿠키, 로컬스토리지, 세션스토리지에 접근해 인증 정보(세션 쿠키, JWT 등)를 탈취하거나, 사용자 대신 원격 API를 호출하는 등 피해자의 권한을 가로챌 수 있기 때문!
            
            - XSS의 종류
                - **Reflected XSS**
                    
                    동작 방식 : 공격자가 XSS 취약점이 존재하는 페이지를 미리 탐색하고, XSS공격을 위한 스크립트가 포함된 URL을 공격 대상자에게 노출시키는 방식. 
                    만약 대상자가 해당 URL을 클릭하게 대상자가 서버와의 Request/Response 과정을 통해 정보가 유출된다. 
                    
                - **Stored XSS**
                    
                    동작방식 : 공격자가 특정 사이트의 게시판 같은 곳에 공격스크립트를 삽입하고 해당 게시글 URL을 공격 대상자에게 노출시키는 방식.
                    
                    만약 대상자가 게시글을 확인함으로써 URL에 대한 요청을 서버에 전송하고 웹 서버에서 사용자에게 공격 스크립트를  포함한 Response를 전송하며 공격이 수행된다.
                    
                - **DOM-based XSS**
                    
                    동작방식 : 공격자가 해시나 쿼리 파라미터 등에 악성 페이로드를 담은 URL을 생성하고 해당 URL을 공격 대상자에게 노출시키는 방식.
                    
                    만약 대상자가 그 URL을 방문하며, 클라이언트 스크립트가 URL에서 값을 읽어 DOM을 조작하면서 악성 스크립트가 수행된다.
                    
            
            - 방어방법
                1. 입력 검증 
                    1. 화이트 리스트 방식 : 허용할 값(숫자, 이메일 등)만 통과
                    2. 블랙리스트 방식 :  <script> 같은 태그·문자열 제거
                2. 안전한 DOM API 사용 : innerHTML보다는 textContent 사용 혹은 노드를 직접 생성하는 방식 사용!
                3. 입력 이스케이프 : 해시나 쿼리 파라미터 값을 HTML에 넣기 전에 적절히 이스케이프!
                4. CSP(Content Security Policy) : 인라인 스크립트나 외부 미승인 스크립트 실행 차단!
                5. HTTPOnly 쿠키 : JS(document.cookie)로 쿠키 접근 불가!
        - CSRF 공격 (Cross-Site Request Forgery)
            
            : 사용자가 신뢰하는 사이트에 **인증된 상태**로 접속해 있을 때, 공격자가 의도한 요청을 **피해자의 권한**으로 실행하도록 유도하는 공격
            
            - CSRF란 무엇인가?
            : 사용자가 이미 로그인해 보유한 세션 쿠키를 브라우저가 자동으로 포함해, 공격자가 만든 페이지나 스크립트가 **피해자의 의도와 무관하게** 정상 API(예: 계좌 이체, 개인정보 변경)를 호출하는 기법이다.
            - 어떤 문제가 발생할 수 있는가?
            : 피해자는 자신도 모르는 사이에 **은행 이체**, **비밀번호 변경** 등 중요한 동작이 공격자 의도대로 수행될 수 있음!
            - 동작 방식 : 공격대상자가 특정 사이트에 로그인해 쿠키를 보유하고 있으면 공격자가 이메일이나 SNS링크를 통해 공격자가 만든 사이트를 방문하게 유도한다.
            만약 대상자가 페이지를 방문하게 되면 특정 사이트에 도메인 쿠키를 자동으로 포함해 요청하는 하는 방식으로 공격한다. 서버는 정상적인 로그인 세션으로 인식하고 해당 동작을 수행한다.
            
            - 방어 기법
                1. CSRF 토큰 : 서버가 세션별 고유 난수 토큰을 발급, 모든 상태 변경 요청에 해당 토큰을 포함하고 서버는 요청 토큰과 세션 토큰 일치 여부를 검증한다. 
                즉, 공격자는 세션별 고유 난수 토큰을 보유하고 있지 않아서 방어 가능! 
                2. SameSite 쿠키 : 다른 사이트에서 전송된 요청에는 쿠키 미포함!
                3. 토근 기반 인증(Bearer) : 로그인 후 발급받은 JWT를 Authorization 헤더에 수동 설정하므로 브라우저가 자동으로 헤더를 추가하지 않아서 방어가 가능하다!
                4. Referer/Origin 검증 : 요청 헤더의 Referer 또는 Origin 값이 자신의 도메인인지 확인한다.
                
- Protected Route 🍠
    - Protected Route 니가 뭔데~🎶
        
        ### Protected Route 니가 뭔데~🎶
        
        - **정의:**
            
            `Protected Route`는 인증 상태(예: 로그인 여부)에 따라 특정 라우트를 보호하는 컴포넌트입니다. 사용자가 인증된 경우에만 접근을 허용하고, 그렇지 않은 경우 로그인 페이지나 오류 페이지로 리다이렉션 시킵니다.
            
        - **목적:**
            - 사용자 데이터 보호
            - 민감한 정보에 대한 접근 제한
            - 사용자 경험 개선 (잘못된 접근 시 안내 제공)
        
        <aside>
        🗣
        
        **`Protected Route`**를 적용하지 않은 경우 어떤 문제가 발생할까요?
        
        **`/admin/users` 페이지의 역할**
        
         해당 페이지는 관리자(admin)만 접근할 수 있도록 설계되어, 웹사이트에 가입한 모든 유저들의 정보를 보여줍니다.
        
        **Protected Route를 적용하지 않은 경우 발생하는 문제**
        
        **일반 사용자 접근:** 일반 유저도 `/admin/users` 페이지에 접근할 수 있게 되어, 관리자 전용 정보(다른 유저들의 개인정보 등)가 노출됩니다.
        
        **보안 취약점:** 이는 서비스의 보안에 심각한 위험을 초래하며, 데이터 유출이나 권한 없는 정보 접근으로 이어질 수 있습니다.
        
        </aside>
        
    - Protected Route의 동작 원리
        
        ### Protected Route의 동작 원리
        
        1. **인증 확인**
            
            애플리케이션의 상태(예: Context, Redux, 또는 로컬 스토리지 등)를 통해 사용자의 로그인 상태나 권한을 확인합니다.
            
        2. **조건 분기**
            - 인증된 사용자인 경우: 요청한 컴포넌트를 렌더링합니다.
            - 인증되지 않은 사용자인 경우: 로그인 페이지, 홈 페이지 등으로 리다이렉션합니다.
        3. **리다이렉션 처리**
            
            미인증 상태에서 접근을 시도하면, 사용자에게 로그인 후 원래 요청한 페이지로 돌아갈 수 있도록 리다이렉션 정보를 전달할 수 있습니다.
            
    - Protected Route를 직접 구현해보세요 🍠
        
        ### 실습 🍠
        
        서버가 없으니, 아래와 같이 가상의 역할을 만들어 직접 구현해보세요!
        
        ```tsx
        // 가상의 사용자 역할
        const role = 'ADMIN' as const;
        
        // 공개 라우트
        const publicRoutes: RouteObject[] = [
          {
            path: '/',
            element: <HomeLayout />,
            errorElement: <NotFoundPage />,
            children: [
              { index: true, element: <HomePage /> },
              { path: 'login', element: <LoginPage /> },
              { path: 'signup', element: <SignUpPage /> },
              { path: 'v1/auth/google/callback', element: <GoogleLoginRedirectPage /> },
            ],
          },
        ];
        
        // 역할 기반 보호 라우트
        const protectedRoutes: RouteObject[] = [
          {
            path: '/',
            element: <ProtectedLayout />,
            errorElement: <NotFoundPage />,
            children: [
              {
                path: 'my',
                element:
                  // ADMIN 역할이 아니면 로그인 페이지로 리다이렉트
                  role === 'ADMIN' ? <MyPage /> : <Navigate to="/login" replace />,
              },
            ],
          },
        ];
        
        const router = createBrowserRouter([...publicRoutes, ...protectedRoutes])
        ```
        
- OAuth 2.0
    - OAuth 2.0 이란?
        
        ### OAuth 2.0이란?
        
        - **정의**
            
            OAuth 2.0은 사용자가 자신의 리소스(예: 프로필, 이메일 등)를 제3자 애플리케이션과 공유할 수 있도록, 안전하고 제한적인 접근 권한을 위임하는 프로토콜입니다.
            
        - **목적**
            - **보안 강화:** 사용자 비밀번호를 노출하지 않고, 액세스 토큰을 통해 리소스 접근을 제어합니다.
            - **유연성 제공:** 다양한 클라이언트(웹, 모바일 등)에서 사용 가능한 여러 인증 방식을 지원합니다.
        
    - 주요 구성 요소
        
        ### OAuth 2.0 주요 구성 요소
        
        OAuth 2.0은 다음 네 가지 핵심 구성 요소로 이루어져 있습니다.
        
        ---
        
        **1. 리소스 소유자 (Resouce Owner)**
        
        - 데이터나 리소스의 소유자(주로 사용자)로, 자신의 정보를 제3자에게 공유할 수 있는 권한을 가지고 있습니다.
        
        **2. 클라이언트 (Client)**
        
        - 리소스 소유자의 데이터에 접근하려는 애플리케이션입니다. 예를 들어, 서드파티 앱이나 웹사이트가 이에 해당합니다.
        
        **3. 리소스 서버 (Resource Server)**
        
        - 보호된 리소스를 호스팅하는 서버로, 클라이언트의 요청 시 액세스 토큰을 확인하여 데이터에 대한 접근 권한을 검증합니다.
        
        **4. 인가 서버 (Authorization Server)**
        
        - 리소스 소유자의 인증을 담당하며, 클라이언트에게 액세스 토큰을 발급하는 역할을 합니다.
        
    - OAuth 2.0 인증 및 권한 부여 프로세스
        
        ### OAuth 2.0 인증 및 권한 부여 프로세스
        
        **OAuth 2.0**의 전형적인 흐름은 다음 단계로 진행됩니다.
        
        ---
        
        1. **사용자 인증 및 권한 부여 요청**
            
            클라이언트 애플리케이션이 **리소스 소유자**에게 특정 리소스에 접근할 수 있도록 허용할지를 요청합니다.
            
        2. **인가 코드 발급 (Authorization Code Grant)**
            
            인가 서버는 **리소스 소유자**가 동의하면 클라이언트에게 인가 코드를 발급합니다. 이 코드는 일회용이며, 액세스 토큰 요청 시 사용됩니다.
            
        3. **액세스 토큰 발급:**
            
            클라이언트는 받은 인가 코드를 인가 서버에 제출하고, 유효하다면 액세스 토큰을 발급받습니다. 이 토큰은 **리소스 서버**에 보호된 데이터를 요청할 때 사용됩니다.
            
        4. **리소스 접근:**
            
            클라이언트는 액세스 토큰을 사용해 **리소스 서버**에서 보호된 데이터를 요청합니다.
            
        
    - OAuth 2.0의 인증 방식 (Grant Types)
        
        ### OAuth 2.0의 인증 방식 (Grant Types)
        
        OAuth 2.0은 다양한 상황에 맞게 여러 가지 인증 방식을 제공합니다.
        
        ### 1. Authorization Code Grant
        
        - **용도:** 서버 사이드 애플리케이션에서 주로 사용됩니다.
        - **특징:** 인가 코드를 통해 액세스 토큰을 교환하므로, 비교적 보안성이 높습니다.
        
        ### 2. Implicit Grant
        
        - **용도:** 브라우저 기반 애플리케이션(예: SPA)에서 사용됩니다.
        - **특징:** 액세스 토큰이 직접 클라이언트로 전달되지만, 보안 측면에서는 약간의 위험이 있을 수 있습니다.
        
        ### 3. Resource Owner Password Credentials Grant
        
        - **용도:** 사용자의 신뢰도가 높은 클라이언트(예: 자체 앱)에서 사용됩니다.
        - **특징:** 사용자 이름과 비밀번호를 직접 받아 토큰을 요청하므로, 다른 방식보다 보안 위험이 있을 수 있습니다.
        
        ### 4. Client Credentials Grant
        
        - **용도:** 서버 간 통신이나, 애플리케이션이 자신을 인증할 때 사용됩니다.
        - **특징:** 클라이언트 자신의 자격 증명을 사용해 토큰을 발급받습니다.
        
        ### 5. Refresh Token
        
        - **용도:** 만료된 액세스 토큰을 갱신하기 위해 사용됩니다.
        - **특징:** 장기적으로 사용자의 인증 상태를 유지할 수 있도록 도와줍니다.
    - OAuth 2.0과 OpenID Connect
        
        ### OAuth 2.0과 OpenID Connect
        
        - **OAuth 2.0**
            
            주로 권한 부여에 초점을 맞추어, 리소스 접근 권한을 관리합니다.
            
        - **OpenID Connect (OIDC)**
            
            OAuth 2.0 위에 구축된 인증 계층으로, 사용자 인증 및 프로필 정보를 제공하여 단일 로그인을 구현할 때 사용됩니다.
            
    - OAuth 2.0 장점 및 단점
        
        ### OAuth 2.0 장점 및 단점
        
        ### 1. 장점
        
        - **보안성 강화:** 사용자의 민감한 자격 증명을 노출하지 않고, 액세스 토큰을 통한 접근 제어가 가능합니다.
        - **유연성:** 다양한 클라이언트와 인증 방식을 지원하며, 서버와 클라이언트를 분리하여 확장이 용이합니다.
        - **표준화:** 널리 사용되는 표준 프로토콜로, 다양한 플랫폼과 서비스 간에 호환성이 좋습니다.
        
        ### 2. 단점
        
        - **구현 복잡성:** 여러 가지 플로우와 구성 요소 때문에 초기 설정 및 구현이 다소 복잡할 수 있습니다.
        - **보안 취약점 가능성:** 잘못된 구현이나 설정 시 리다이렉션 URI 변조, 토큰 탈취 등의 보안 위험이 발생할 수 있습니다.